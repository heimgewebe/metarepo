name: Heimgewebe command dispatch

on:
  # Dieser Workflow wird von anderen Repos via "workflow_call" eingebunden.
  workflow_call:
    secrets:
      HEIMGEWEBE_AUTOBOT_TOKEN:
        required: true

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  dispatch:
    name: Parse and dispatch Heimgewebe command
    runs-on: ubuntu-latest
    env:
      # Whitelist der Ziel-Repos (kommagetrennt). Kann pro Repo via
      # Repository-Variable HEIMGEWEBE_ALLOWED_REPOS Ã¼berschrieben werden.
      ALLOWED_TARGET_REPOS: ${{ vars.HEIMGEWEBE_ALLOWED_REPOS || 'sichter,wgx,heimgeist,metarepo,hausKI,semantAH,heimlern,chronik,leitstand,tools' }}
      # Whitelist der erlaubten Kommandos (kommagetrennt). Kann via
      # Repository-Variable HEIMGEWEBE_ALLOWED_COMMANDS Ã¼berschrieben werden.
      ALLOWED_COMMANDS: ${{ vars.HEIMGEWEBE_ALLOWED_COMMANDS || 'quick,deep' }}
      # Ob Org-Mitgliedschaft als Voraussetzung geprÃ¼ft werden soll.
      # true  (Standard): nur aktive Org-Mitglieder (plus Owner) dÃ¼rfen Heimgewebe-Kommandos ausfÃ¼hren.
      # false: jeder, der kommentieren darf, kann Heimgewebe-Kommandos auslÃ¶sen.
      REQUIRE_ORG_MEMBERSHIP: ${{ vars.HEIMGEWEBE_REQUIRE_ORG_MEMBERSHIP || 'true' }}

    steps:
      - name: Parse and dispatch command
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.HEIMGEWEBE_AUTOBOT_TOKEN }}
          script: |
            const allowedRepos = (process.env.ALLOWED_TARGET_REPOS || '')
              .split(',')
              .map(s => s.trim())
              .filter(Boolean);
            const allowedCommands = (process.env.ALLOWED_COMMANDS || '')
              .split(',')
              .map(s => s.trim())
              .filter(Boolean);

            const comment = (context.payload.comment && context.payload.comment.body) || '';
            const issue = context.payload.issue || context.payload.pull_request || {};
            const repoFull = context.repo; // { owner, repo }
            const author = context.payload.comment && context.payload.comment.user && context.payload.comment.user.login;
            const requireOrgMembership =
              (process.env.REQUIRE_ORG_MEMBERSHIP || 'true').toLowerCase() === 'true';
            const isOwner =
              author &&
              repoFull.owner &&
              author.toLowerCase() === repoFull.owner.toLowerCase();

            core.info(`Heimgewebe dispatch invoked for ${repoFull.owner}/${repoFull.repo}#${issue.number || 'n/a'} by ${author || 'unknown'}`);

            // Debug: rohen Kommentar einmal ins Log schreiben, um Parsing-Probleme zu sehen
            core.info(`Raw comment body: ${JSON.stringify(comment)}`);

            if (!comment) {
              core.info('No comment body â€“ abort.');
              return;
            }

            // Muster: @heimgewebe/<zielrepo> /<kommando> [arg...]
            // Robustere Variante:
            // - erlaubt Klein-/GroÃŸschreibung
            // - erlaubt Punkte und Minus im Repo- und Kommandonamen
            // - frisst alle weiteren Zeichen (inkl. ZeilenumbrÃ¼che) als Args
            const pattern = /@heimgewebe\/([a-z0-9_.-]+)\s+\/([a-z0-9_.-]+)\b([\s\S]*)/i;
            const match = pattern.exec(comment);

            if (!match) {
              core.info('No Heimgewebe command found in comment (pattern did not match).');
              return;
            }

            const targetRepo = match[1];
            const command = match[2];
            const rawArgs = (match[3] || '').trim();

            // Kommentar-Inhalt sanitisieren und kÃ¼rzen (keine ZeilenumbrÃ¼che, max. 2048 Zeichen)
            const maxCommentLen = 2048;
            let sanitizedComment = comment.replace(/[\r\n]+/g, ' ');
            if (sanitizedComment.length > maxCommentLen) {
              sanitizedComment = sanitizedComment.slice(0, maxCommentLen) + ' â€¦(gekÃ¼rzt)';
            }

            async function reply(body) {
              if (!issue.number) {
                core.info('No issue / PR number found â€“ cannot post reply.');
                return;
              }
              await github.rest.issues.createComment({
                owner: repoFull.owner,
                repo: repoFull.repo,
                issue_number: issue.number,
                body,
              });
            }

            // Whitelist-Checks
            if (!allowedRepos.includes(targetRepo)) {
              await reply(
                `ðŸ‘‹ Heimgewebe hat deinen Befehl erkannt, aber **${targetRepo}** ist kein erlaubtes Ziel-Repo.\n\n` +
                `Erlaubte Repos: \`${allowedRepos.join(', ')}\`.`
              );
              return;
            }

            if (!allowedCommands.includes(command)) {
              await reply(
                `ðŸ‘‹ Heimgewebe hat deinen Befehl erkannt, aber das Kommando **${command}** ist hier nicht erlaubt.\n\n` +
                `Erlaubte Kommandos: \`${allowedCommands.join(', ')}\`.`
              );
              return;
            }

            // Autorisierung:
            // - Owner: immer erlaubt
            // - sonst je nach Konfiguration nur aktive Org-Mitglieder
            let isMember = false;
            if (isOwner) {
              core.info('Author is org owner â€“ skipping membership check.');
            } else if (requireOrgMembership) {
              try {
                const membership = await github.rest.orgs.getMembershipForUser({
                  org: repoFull.owner,
                  username: author,
                });
                isMember =
                  membership &&
                  membership.status === 200 &&
                  membership.data &&
                  membership.data.state === 'active';
              } catch (err) {
                core.info(`Org membership check failed or user is not a member: ${err.message}`);
                isMember = false;
              }

              if (!isMember) {
                await reply('ðŸš« Heimgewebe-Befehle kÃ¶nnen nur von aktiven Mitgliedern der Organisation ausgefÃ¼hrt werden.');
                return;
              }
            } else {
              core.info('Org membership check disabled via REQUIRE_ORG_MEMBERSHIP â€“ allowing all commenters.');
            }

            const payload = {
              version: 1,
              source_repository: `${repoFull.owner}/${repoFull.repo}`,
              source_issue_number: issue.number,
              source_comment_author: author,
              command,
              target_repo: targetRepo,
              args: rawArgs,
              raw_comment: sanitizedComment,
            };

            core.info(`Dispatching Heimgewebe command to ${targetRepo}: ${JSON.stringify(payload)}`);

            await github.rest.repos.createDispatchEvent({
              owner: repoFull.owner,
              repo: targetRepo,
              event_type: 'heimgewebe-command',
              client_payload: payload,
            });

            // Acknowledge beim Kommentar
            if (context.payload.comment && context.payload.comment.id) {
              try {
                await github.rest.reactions.createForIssueComment({
                  owner: repoFull.owner,
                  repo: repoFull.repo,
                  comment_id: context.payload.comment.id,
                  content: 'eyes',
                });
              } catch (e) {
                core.info(`Could not add reaction: ${e.message}`);
              }
            }

            await reply(
              `âœ… Heimgewebe-Befehl wurde an \`${targetRepo}\` gesendet.\n\n` +
              `Kommando: \`${command}\`${rawArgs ? ' `' + rawArgs + '`' : ''}`
            );
