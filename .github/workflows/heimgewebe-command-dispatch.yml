name: Heimgewebe command dispatch

on:
  # Wird aus anderen Repos via "workflow_call" eingebunden.
  workflow_call:
    secrets:
      HEIMGEWEBE_APP_ID:
        required: true
      HEIMGEWEBE_APP_PRIVATE_KEY:
        required: true

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  dispatch:
    name: Parse and dispatch Heimgewebe command
    runs-on: ubuntu-latest

    env:
      # Whitelist der Ziel-Repos (kommagetrennt). Kann pro Repo via
      # Repository-Variable HEIMGEWEBE_ALLOWED_REPOS Ã¼berschrieben werden.
      ALLOWED_TARGET_REPOS: ${{ vars.HEIMGEWEBE_ALLOWED_REPOS || 'sichter,wgx,heimgeist,metarepo,hausKI,semantAH,heimlern,chronik,leitstand,tools' }}

      # Whitelist der erlaubten Kommandos (kommagetrennt). Kann via
      # Repository-Variable HEIMGEWEBE_ALLOWED_COMMANDS Ã¼berschrieben werden.
      ALLOWED_COMMANDS: ${{ vars.HEIMGEWEBE_ALLOWED_COMMANDS || 'quick,deep' }}

      # true  (Standard): nur aktive Org-Mitglieder (plus Owner) dÃ¼rfen Heimgewebe-Kommandos ausfÃ¼hren.
      # false: jeder, der kommentieren darf, kann Heimgewebe-Kommandos auslÃ¶sen.
      REQUIRE_ORG_MEMBERSHIP: ${{ vars.HEIMGEWEBE_REQUIRE_ORG_MEMBERSHIP || 'true' }}

    steps:
      - name: Create GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.HEIMGEWEBE_APP_ID }}
          private-key: ${{ secrets.HEIMGEWEBE_APP_PRIVATE_KEY }}
          owner: heimgewebe

      - name: Parse and dispatch command
        uses: actions/github-script@v7
        with:
          # Lesen, Antworten und Dispatch mit dem App-Installationstoken
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const allowedRepos = (process.env.ALLOWED_TARGET_REPOS || "")
              .split(",")
              .map((s) => s.trim())
              .filter(Boolean);

            const allowedCommands = (process.env.ALLOWED_COMMANDS || "")
              .split(",")
              .map((s) => s.trim())
              .filter(Boolean);

            const comment = (context.payload.comment && context.payload.comment.body) || "";
            const issue = context.payload.issue || context.payload.pull_request || {};
            const repoFull = context.repo; // { owner, repo }
            const author = context.payload.comment?.user?.login;
            const authorType = context.payload.comment?.user?.type || "unknown";

            const requireOrgMembership =
              (process.env.REQUIRE_ORG_MEMBERSHIP || "true").toLowerCase() === "true";

            const assoc =
              context.payload.comment?.author_association || "UNKNOWN";

            core.info(
              `Heimgewebe dispatch invoked for ${repoFull.owner}/${repoFull.repo}#${issue.number || "n/a"} by ${author || "unknown"}`
            );
            core.info(`author_association = ${assoc}, author_type = ${authorType}`);
            core.info(`Raw comment body: ${JSON.stringify(comment)}`);

            // Bot-Kommentare grundsÃ¤tzlich ignorieren (Schutz vor Loops)
            if (authorType === "Bot" || (author && author.endsWith("[bot]"))) {
              core.info("Ignoring bot comment.");
              return;
            }

            if (!comment) {
              core.info("No comment body â€“ abort.");
              return;
            }

            // ROBUSTER ERKENNER FÃœR KOMMANDOS
            //
            // Erlaubt u. a.:
            // @heimgewebe/sichter quick
            // @heimgewebe/sichter    quick
            // @heimgewebe/sichter /quick
            // @heimgewebe/sichter
            //     /quick extra
            // @HEIMGEWEBE/SICHTER /QUICK
            // @heimgewebe/sichter        / quick foo bar
            //
            // Strategie:
            // 1. Finde @heimgewebe/<repo>
            // 2. Dahinter beliebiger Whitespace
            // 3. Optional "/" vor dem Kommando
            // 4. Kommando
            // 5. Rest = Args
            const tolerantPattern =
              /@heimgewebe\/([a-z0-9_.-]+)\s*(?:\/\s*)?([a-z0-9_.-]+)\b([\s\S]*)/i;

            const match = tolerantPattern.exec(comment);

            if (!match) {
              core.info("No Heimgewebe command found (tolerant pattern did not match).");
              return;
            }

            const targetRepo = match[1];
            const command = match[2];
            const rawArgs = (match[3] || "").trim();

            // Kommentar sanitisieren (eine Zeile, max. 2048 Zeichen)
            const maxCommentLen = 2048;
            let sanitizedComment = comment.replace(/[\r\n]+/g, " ");
            if (sanitizedComment.length > maxCommentLen) {
              sanitizedComment = sanitizedComment.slice(0, maxCommentLen) + " â€¦(gekÃ¼rzt)";
            }

            async function reply(body) {
              if (!issue.number) {
                core.info("No issue / PR number found â€“ cannot post reply.");
                return;
              }
              await github.rest.issues.createComment({
                owner: repoFull.owner,
                repo: repoFull.repo,
                issue_number: issue.number,
                body,
              });
            }

            // Whitelist-Checks
            if (!allowedRepos.includes(targetRepo)) {
              await reply(
                `ðŸ‘‹ Heimgewebe hat deinen Befehl erkannt, aber **${targetRepo}** ist kein erlaubtes Ziel-Repo.\n\n` +
                `Erlaubte Repos: \`${allowedRepos.join(", ")}\`.`
              );
              return;
            }

            if (!allowedCommands.includes(command)) {
              await reply(
                `ðŸ‘‹ Heimgewebe hat deinen Befehl erkannt, aber das Kommando **${command}** ist hier nicht erlaubt.\n\n` +
                `Erlaubte Kommandos: \`${allowedCommands.join(", ")}\`.`
              );
              return;
            }

            // Membership check nur Ã¼ber author_association (kein extra API-Call)
            const allowedRoles = ["OWNER", "MEMBER"];
            if (requireOrgMembership) {
              if (!allowedRoles.includes(assoc)) {
                await reply(
                  "ðŸš« Heimgewebe-Befehle kÃ¶nnen nur von aktiven Mitgliedern oder dem Owner ausgefÃ¼hrt werden."
                );
                return;
              }
              core.info(`User allowed via author_association = ${assoc}`);
            } else {
              core.info(
                `Org membership check disabled via REQUIRE_ORG_MEMBERSHIP â€“ allowing all commenters (assoc=${assoc}).`
              );
            }

            const payload = {
              version: 1,
              source_repository: `${repoFull.owner}/${repoFull.repo}`,
              source_issue_number: issue.number,
              source_comment_author: author,
              command,
              target_repo: targetRepo,
              args: rawArgs,
              raw_comment: sanitizedComment,
            };

            core.info(
              `Dispatching Heimgewebe command to ${targetRepo}: ${JSON.stringify(payload)}`
            );

            await github.request("POST /repos/{owner}/{repo}/dispatches", {
              owner: "heimgewebe",
              repo: targetRepo,
              event_type: "heimgewebe-command",
              client_payload: payload,
            });

            // Acknowledge beim Kommentar
            if (context.payload.comment?.id) {
              try {
                await github.rest.reactions.createForIssueComment({
                  owner: repoFull.owner,
                  repo: repoFull.repo,
                  comment_id: context.payload.comment.id,
                  content: "eyes",
                });
              } catch (e) {
                core.info(`Could not add reaction: ${e.message}`);
              }
            }

            await reply(
              `âœ… Heimgewebe-Befehl wurde an \`${targetRepo}\` gesendet.\n\n` +
              `Kommando: \`${command}\`${rawArgs ? " `" + rawArgs + "`" : ""}`
            );