name: toolchain-guard
permissions:
  contents: read
on:
  push:
jobs:
  guard:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v6
      - name: Install yq (robust)
        run: |
          set -euo pipefail
          YQ_VERSION="v4.44.3"
          BIN_DIR="${GITHUB_WORKSPACE}/tools/bin"
          mkdir -p "$BIN_DIR"
          # Add to PATH for subsequent steps in this job
          echo "$BIN_DIR" >> "$GITHUB_PATH"

          TMP_BIN="$(mktemp "$BIN_DIR/yq.dl.XXXXXX")"
          TMP_SHA="$(mktemp "$BIN_DIR/yq.sha256.XXXXXX")"

          echo "Lade yq $YQ_VERSION herunter..."
          # Download binary
          curl --fail --max-time 60 --connect-timeout 10 --retry 3 -fsSL \
            "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64" -o "$TMP_BIN"

          # more robust checksum download & verification
          echo "Download checksums (versuche mehrere mögliche Namen)..."
          SHA_NAMES=(
            "checksums"
            "checksums.txt"
            "SHA256SUMS"
            "yq_linux_amd64.sha256"
            "yq_linux_amd64.sha256.txt"
            "sha256"
          )

          FOUND_SHA=0
          for name in "${SHA_NAMES[@]}"; do
            if curl --fail --max-time 60 --connect-timeout 10 --retry 3 -fsSL \
                "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/${name}" -o "$TMP_SHA"; then
              if [[ -s "$TMP_SHA" ]]; then
                FOUND_SHA=1
                echo "Gefundene Checksums-Datei: $name"
                break
              fi
            fi
          done

          # Fallback: Release-Metadaten durchsuchen und asset-url verwenden
          if [[ $FOUND_SHA -eq 0 ]]; then
            echo "Versuche Release-Metadaten zu parsen und passende Checksums-Asset-URL zu finden..."
            RELEASE_JSON="$(mktemp "$BIN_DIR/release.json.XXXXXX")"
            if curl --fail --max-time 60 --connect-timeout 10 --retry 3 -fsSL \
                "https://api.github.com/repos/mikefarah/yq/releases/tags/${YQ_VERSION}" -o "$RELEASE_JSON"; then
              # Suche nach assets mit "sha" oder "check" im Namen
              ASSET_URL="$(grep -oE '"browser_download_url":\s*"[^\"]+"' "$RELEASE_JSON" \
                | sed -E 's/.*"([^"]+)".*/\1/' \
                | grep -Ei '(sha|check)' || true)"
              if [[ -n "$ASSET_URL" ]]; then
                # nimm erstes Ergebnis
                ASSET_URL="$(printf '%s\n' "$ASSET_URL" | head -n1)"
                echo "Download Checksums von: $ASSET_URL"
                if curl --fail --max-time 60 --connect-timeout 10 --retry 3 -fsSL "$ASSET_URL" -o "$TMP_SHA"; then
                  FOUND_SHA=1
                fi
              fi
            fi
            rm -f "$RELEASE_JSON" || true
          fi

          if [[ $FOUND_SHA -eq 0 ]]; then
            echo "Fehler: Konnte keine Checksums-Datei herunterladen" >&2
            exit 1
          fi

          # Verify checksums file is not empty
          if [[ ! -s "$TMP_SHA" ]]; then
            echo "Fehler: Checksums-Datei ist leer" >&2
            exit 1
          fi

          # Calculate actual sha
          ACTUAL_SHA="$(sha256sum "$TMP_BIN" | awk '{print $1}')"

          # Robustere Extraktion der erwarteten SHA256 aus der Checksums-Datei.
          # Wir suchen zuerst in Zeilen, die auf unseren Dateinamen verweisen und extrahieren das erste 64-hex-Token.
          EXPECTED_SHA="$(
            # Normalisiere Trennzeichen: ersetze alle Whitespaces durch neue Zeilen,
            # damit auch space-separated Einträge korrekt tokenisiert werden.
            tr -s '[:space:]' '\n' < "$TMP_SHA" \
              | awk '
                BEGIN { target_re = "yq_linux_amd64" }
                {
                  # Speichere alle Tokens in Reihenfolge
                  all_tokens[++count] = $0
                }
                END {
                  # Versuch 1: wenn ein Token exakt den Dateinamen enthält, suche in der Nachbarschaft nach einem 64-hex-Hash.
                  for (i=1;i<=count;i++) {
                    if (tolower(all_tokens[i]) ~ target_re) {
                      if (i>1 && all_tokens[i-1] ~ /^[0-9a-fA-F]{64}$/) { print all_tokens[i-1]; exit }
                      if (i<count && all_tokens[i+1] ~ /^[0-9a-fA-F]{64}$/) { print all_tokens[i+1]; exit }
                    }
                  }
                  # Versuch 2: falls oben nichts gefunden, gib erstes 64-hex-Hash-Token zurück
                  for (i=1;i<=count;i++) {
                    if (all_tokens[i] ~ /^[0-9a-fA-F]{64}$/) { print all_tokens[i]; exit }
                  }
                }'
          )" || true

          # Endgültige Prüfung
          if [[ -n "$EXPECTED_SHA" && "$EXPECTED_SHA" == "$ACTUAL_SHA" ]]; then
            echo "SHA256-Prüfsumme erfolgreich verifiziert: $ACTUAL_SHA"
          else
            echo "SHA256-Prüfsumme stimmt nicht überein!" >&2
            echo "Gesuchter Hash: $ACTUAL_SHA" >&2
            echo "Gefundener Hash in Checksums-Datei (falls vorhanden): ${EXPECTED_SHA:-'(kein Hash gefunden)'}" >&2
            echo "Inhalt der Checksums-Datei (erste 200 Zeilen):" >&2
            sed -n '1,200p' "$TMP_SHA" >&2 || true
            exit 1
          fi

          chmod +x "$TMP_BIN"
          mv "$TMP_BIN" "$BIN_DIR/yq"
          echo "yq erfolgreich installiert und verifiziert."
      - name: Install just
        run: scripts/tools/just-pin.sh
      - name: Lint GitHub workflows (actionlint)
        uses: rhysd/actionlint@v1.7.9
        with:
          args: -color
      - name: Show tool versions
        run: |
          set +e
          command -v uv >/dev/null 2>&1 && uv --version
          command -v just >/dev/null 2>&1 && just --version
          command -v yq >/dev/null 2>&1 && yq --version
          command -v gh >/dev/null 2>&1 && gh --version
          command -v ruby >/dev/null 2>&1 && ruby --version
          set -e
