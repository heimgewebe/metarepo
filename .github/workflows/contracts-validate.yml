---
name: "contracts-validate"

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

'on':
  workflow_dispatch: {}
  push:
    paths:
      - "contracts/**"
      - "fixtures/**"
      - ".github/workflows/contracts-validate.yml"
  pull_request:
    paths:
      - "contracts/**"
      - "fixtures/**"
      - ".github/workflows/contracts-validate.yml"

defaults:
  run:
    shell: bash --noprofile --norc -euo pipefail {0}

env:
  FAIL_ON_NO_BASE: "1"
  ALLOW_REMOVALS: "1"  # Temporary: allow intent_event → intent.event rename for canonical dot notation

jobs:
  guard:
    name: "Security: guard deletion policy (contracts)"
    runs-on: ubuntu-latest
    timeout-minutes: 8
    env:
      GH_DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
      GH_PR_BASE_SHA: ${{ github.event.pull_request.base.sha }}
      GH_PUSH_BEFORE: ${{ github.event.before }}
      PROTECTED_REGEX: '^(contracts|fixtures)/'
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Enforce guard policy
        run: |
          set -euo pipefail
          is_truthy() { case "${1:-0}" in 1|true|yes|on) return 0 ;; esac; return 1; }

          if is_truthy "${ALLOW_REMOVALS:-0}"; then
            echo "::notice::ALLOW_REMOVALS=1 → skipping guard"
            exit 0
          fi

          base=""
          base_src=""

          if [[ -n "${GH_PR_BASE_SHA:-}" ]] && git rev-parse --verify "${GH_PR_BASE_SHA}^{commit}" &>/dev/null; then
            if mb="$(git merge-base "$GH_PR_BASE_SHA" HEAD 2>/dev/null)"; then
              base="$mb"; base_src="merge-base(pr_base,HEAD)"
            fi
          fi

          if [[ -z "$base" && -n "${GH_PUSH_BEFORE:-}" && ! "${GH_PUSH_BEFORE}" =~ ^0{40}$ ]] \
             && git rev-parse --verify "${GH_PUSH_BEFORE}^{commit}" &>/dev/null; then
            base="$GH_PUSH_BEFORE"; base_src="push_before"
          fi

          if [[ -z "$base" ]]; then
            git fetch -q origin "${GH_DEFAULT_BRANCH}" || true
            if git rev-parse "origin/${GH_DEFAULT_BRANCH}^{commit}" &>/dev/null; then
              if mb="$(git merge-base "origin/${GH_DEFAULT_BRANCH}" HEAD 2>/dev/null)"; then
                base="$mb"; base_src="merge-base(origin/${GH_DEFAULT_BRANCH},HEAD)"
              fi
            fi
          fi

          if [[ -z "$base" ]]; then
            if is_truthy "${FAIL_ON_NO_BASE:-1}"; then
              echo "::error::Cannot determine merge-base"; exit 1
            else
              echo "::notice::No merge-base found - skipping guard"; exit 0
            fi
          fi

          echo "::notice::Checking diff from ${base:0:8}...HEAD (source=$base_src)"

          blocked=()
          while IFS=$'\t' read -r -a fields; do
            status="${fields[0]}"
            p1="${fields[1]}"
            p2="${fields[2]:-}"
            [[ "$p1" =~ ${PROTECTED_REGEX} ]] || continue
            case "$status" in
              D)  blocked+=("DELETE: $p1") ;;
              R*) blocked+=("RENAME: $p1 → ${p2:-(unknown destination)}") ;;
            esac
          done < <(git diff --name-status --diff-filter=DR "${base}...HEAD")

          if (( ${#blocked[@]} )); then
            echo "::group::❌ Protected file deletions blocked"
            printf '  • %s\n' "${blocked[@]}" | sort -u
            echo "::endgroup::"
            echo "::error::Guard violation"
            exit 1
          fi

          echo "::notice::✅ Guard passed"

  validate:
    name: "Validate Contracts & Examples"
    needs: [guard]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          persist-credentials: false

      - name: Ensure Node available
        uses: actions/setup-node@v6
        with:
          node-version: "20"

      - name: Install ajv-cli
        run: npm install -g ajv-cli@5 ajv-formats

      - name: Validate Schemas (compile)
        run: |
          shopt -s nullglob
          schemas=( contracts/**/*.schema.json )

          if [ ${#schemas[@]} -eq 0 ]; then
            echo "::notice::No schema files found in contracts/ - skipping compilation"
            exit 0
          fi

          echo "Compiling ${#schemas[@]} schema(s)..."
          for schema in "${schemas[@]}"; do
            echo "Compiling $schema"
            # Check if schema references base.event.schema.json and include it if so
            if grep -q '"$ref".*base\.event\.schema\.json' "$schema" 2>/dev/null; then
              echo "  → Schema references base.event.schema.json, including as reference"
              ajv compile -s "$schema" -r contracts/events/base.event.schema.json --strict=log --spec=draft2020 -c ajv-formats
            else
              ajv compile -s "$schema" --strict=log --spec=draft2020 -c ajv-formats
            fi
          done

      - name: Validate Specific Examples
        run: |
          # Explicitly requested validation
          if [[ -f contracts/examples/knowledge.observatory.example.json && -f contracts/knowledge.observatory.schema.json ]]; then
            echo "Validating knowledge.observatory example..."
            ajv validate \
              -s contracts/knowledge.observatory.schema.json \
              -d contracts/examples/knowledge.observatory.example.json \
              --strict=false \
              -c ajv-formats --spec=draft2020
          else
            echo "::warning::Knowledge observatory schema or example not found"
          fi

      - name: Validate All Examples
        run: |
          shopt -s nullglob
          # Find all examples that match the pattern *.json (including .example.json)
          for example in contracts/examples/*.json; do
            # Extract base name, handling .example.json or just .json
            base=$(basename "$example" .json)
            filename=${base%.example}
            
            # Try to find schema in contracts/ or contracts/events/
            schema=""
            if [[ -f "contracts/${filename}.schema.json" ]]; then
              schema="contracts/${filename}.schema.json"
            elif [[ -f "contracts/events/${filename}.schema.json" ]]; then
              schema="contracts/events/${filename}.schema.json"
            fi

            if [[ -n "$schema" ]]; then
              echo "Validating $example against $schema"
              # Check if schema references base.event.schema.json
              if grep -q '"$ref".*base\.event\.schema\.json' "$schema" 2>/dev/null; then
                echo "  → Schema references base.event.schema.json, including as reference"
                ajv validate \
                  -s "$schema" \
                  -r contracts/events/base.event.schema.json \
                  -d "$example" \
                  --strict=false \
                  -c ajv-formats --spec=draft2020
              else
                ajv validate \
                  -s "$schema" \
                  -d "$example" \
                  --strict=false \
                  -c ajv-formats --spec=draft2020
              fi
            else
              echo "::notice::No matching schema found for $example (tried contracts/${filename}.schema.json and contracts/events/${filename}.schema.json)"
            fi
          done

      - name: Validate Contract Examples (Explicit)
        run: |
          set -euo pipefail
          if [ -f contracts/examples/knowledge.observatory.example.json ]; then
            ajv validate \
              -s contracts/knowledge.observatory.schema.json \
              -d contracts/examples/knowledge.observatory.example.json \
              --strict=false \
              -c ajv-formats --spec=draft2020
          else
            echo "::error::Missing contract example: contracts/examples/knowledge.observatory.example.json"
            exit 1
          fi

      - name: Validate Fixtures
        run: |
          shopt -s nullglob globstar
          schemas=( contracts/**/*.schema.json )
          fixtures=( fixtures/**/*.jsonl )

          if [ ${#schemas[@]} -eq 0 ]; then
            echo "::notice::No schema files found - skipping validation"
            exit 0
          fi

          if [ ${#fixtures[@]} -eq 0 ]; then
             echo "::notice::No fixtures found."
             exit 0
          fi

          echo "Found ${#schemas[@]} schema(s) and ${#fixtures[@]} fixture(s)"

          # Validate each schema-fixture pair
          # Note: ajv validate -s accepts only one schema file
          for schema in "${schemas[@]}"; do
            for fixture in "${fixtures[@]}"; do
              echo "Validating $fixture against $schema"
              ajv validate \
                -s "$schema" \
                -d "$fixture" \
                --spec=draft2020 \
                --all-errors \
                --errors=line \
                -c ajv-formats \
                --strict=log
            done
          done
